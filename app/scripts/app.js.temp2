    
    console.log(`Asset search query: ${encodedQuery}`);
    console.log(`Full API path will be: assets?include=type_fields&query=${encodedQuery}`);
    
    // Array to store results from this page
    let pageAssets = [];
    
    // Function to load assets from a specific page
    async function loadAssetsPage(page = 1) {
      console.log(`Loading assets page ${page}${assetQuery ? ' with filter ' + assetQuery : ''}`);
      try {
        // Start with base parameters - only include type_fields and pagination
        let queryParam = `?include=type_fields&page=${page}&per_page=100`;
        
        // Add the filter parameter for asset_type_id (don't use the query parameter for this)
        if (assetTypeId && assetTypeId > 0) {
          queryParam += `&filter="asset_type_id:${assetTypeId}"`;
          console.log(`Using asset type filter: asset_type_id:${assetTypeId}`);
        }
        
        // Add search parameter for the search term if provided
        if (searchTerm) {
          const formattedSearch = `"name:'${searchTerm}'"`;
          queryParam += `&search=${encodeURIComponent(formattedSearch)}`;
          console.log(`Using search parameter: ${formattedSearch}`);
        }
        
        console.log(`API request path: ${queryParam}`);
        
        const data = await window.client.request.invokeTemplate("getAssets", {
          path_suffix: queryParam
        });
        
        if (!data || !data.response) {
          return { assets: [] };
        }
        
        try {
          const response = JSON.parse(data.response);
          const assets = response && response.assets ? response.assets : [];
          console.log(`Asset search returned ${assets.length} results`);
          
          // Log a sample asset to see the structure (if available)
          if (assets.length > 0) {
            console.log('Sample asset structure:', {
              id: assets[0].id,
              name: assets[0].name,
              display_name: assets[0].display_name,
              asset_type_id: assets[0].asset_type_id,
              type_fields: assets[0].type_fields,
              custom_fields: assets[0].custom_fields
            });
            
            // Check if the assets match the requested asset type
            if (assetTypeId && assetTypeId > 0) {
              const matchingAssets = assets.filter(a => a.asset_type_id === assetTypeId);
              console.log(`ASSET TYPE FILTERING: ${matchingAssets.length} of ${assets.length} assets match requested type ID ${assetTypeId}`);
              
              if (matchingAssets.length === 0 && assets.length > 0) {
                // Log all unique asset types returned to help troubleshoot
                const uniqueTypes = [...new Set(assets.map(a => a.asset_type_id))];
                console.log(`Found these asset types instead: ${uniqueTypes.join(', ')}`);
              }
            }
          }
          
          // Store the results for this page
          pageAssets = assets;
          
          // Check if we have more results
          assetSearchState.hasMoreResults = assets.length === 100;
          
          // If this was called for infinite scroll, we're done with just this page
          if (pageNum > 1) {
            return { assets: assets };
          }
          
          // For normal search or refresh, we continue with pagination
          // If we got a full page of results, there might be more
          if (assets.length === 100 && page < 3) { // Limit to 3 pages (300 results) max for initial load
            // Get pagination delay from params
            const paginationDelay = params.paginationDelay || DEFAULT_PAGINATION_DELAY;
            
            updateLoadingMessage('asset-results', `Loading more results... (page ${page + 1})`);
            
            // Wait for the delay before loading the next page
            await new Promise(resolve => setTimeout(resolve, paginationDelay));
            
            // Load next page
            return await loadAssetsPage(page + 1);
          }
          
          return { assets: pageAssets };
        } catch (error) {
          console.error('Error parsing assets response:', error);
          return { assets: pageAssets };
        }
      } catch (error) {
        console.error('Asset search failed:', error);
        return { assets: pageAssets };
      }
    }
    
    // Start loading assets from the specified page
    loadAssetsPage(pageNum)
      .then(function(assetsResponse) {
        try {
          // Get assets from the response
          const assets = assetsResponse.assets || [];
          
          // Apply filters based on search strategy
          let filteredAssets = assets;
          
          // If filtered_assets strategy, filter by asset type if API didn't do it
          if (searchStrategy === 'filtered_assets' && assetTypeId) {
            filteredAssets = assets.filter(asset => asset.asset_type_id === assetTypeId);
            console.log(`Manual asset type filtering: ${filteredAssets.length} of ${assets.length} assets remain`);
          }
          
          // Further filter by search term if provided
          if (searchTerm) {
            const initialCount = filteredAssets.length;
            filteredAssets = filteredAssets.filter(asset => {
              const searchIn = [
                asset.name || '',
                asset.display_name || '',
                asset.description || '',
                asset.asset_tag || '',
                asset.serial_number || '',
                asset.product_name || '',
                asset.vendor_name || ''
              ].map(text => String(text).toLowerCase()).join(' ');
              
              return searchIn.includes(searchTerm.toLowerCase());
            });
            
            console.log(`Search term filtering "${searchTerm}": ${filteredAssets.length} of ${initialCount} assets remain`);
          }
          
          // Process assets to include only the fields we need
          const processedAssets = processAssetResults(filteredAssets);
          
          // For infinite scroll (page > 1), append to existing results
          if (pageNum > 1) {
            // Get existing cached results with asset type ID
            getAssetsByTypeFromCache(searchTerm, assetTypeId).then(existingResults => {
              // Remove the loading indicator
              const loadingIndicator = document.getElementById('load-more-indicator');
              if (loadingIndicator) {
                loadingIndicator.remove();
              }
              
              // If we have existing results, merge them with new ones
              if (existingResults && existingResults.length > 0) {
                // Create a set of existing IDs for deduplication
                const existingIds = new Set(existingResults.map(item => item.id));
                
                // Find new results that don't exist in the cache
                const newResults = processedAssets.filter(item => !existingIds.has(item.id));
                
                if (newResults.length > 0) {
                  console.log(`Found ${newResults.length} new unique results`);
                  
                  // Combine existing and new results
                  const combinedResults = [...existingResults, ...newResults];
                  
                  // Update the cache with asset type ID
                  addAssetsToTypeCache(searchTerm, assetTypeId, combinedResults);
                  
                  // Append only the new results to the display
                  displayAdditionalAssetResults('asset-results', newResults, selectAsset);
                  
                  // Update the total count
                  assetSearchState.totalResults += newResults.length;
                } else {
                  console.log('No new unique results found');
                  
                  // Update UI to show no more results
                  const resultsContainer = document.getElementById('asset-results');
                  const noMoreMessage = document.createElement('div');
                  noMoreMessage.className = 'text-center p-3 text-muted';
                  noMoreMessage.textContent = 'No more results';
                  resultsContainer.appendChild(noMoreMessage);
                  
                  // Mark as no more results
                  assetSearchState.hasMoreResults = false;
                }
              } else {
                // No existing results, use the new ones
                addAssetsToTypeCache(searchTerm, assetTypeId, processedAssets);
                displayAssetResults('asset-results', processedAssets, selectAsset);
                assetSearchState.totalResults = processedAssets.length;
              }
              
              // Reset loading state
              assetSearchState.isLoading = false;
            }).catch(error => {
              console.error('Error getting cached results:', error);
              assetSearchState.isLoading = false;
            });
          } else {
            // Initial search or refresh
            // Cache the results with asset type ID
            addAssetsToTypeCache(searchTerm, assetTypeId, processedAssets);
            
            // Display the results
            displayAssetResults('asset-results', processedAssets, selectAsset);
            
            // Setup scroll event listener after initial results are displayed
            setupAssetSearchScroll();
            
            // Update the total count
            assetSearchState.totalResults = processedAssets.length;
          }
        } catch (error) {
          console.error('Error processing asset search results:', error);
          
          // Remove the loading indicator if it exists
          const loadingIndicator = document.getElementById('load-more-indicator');
          if (loadingIndicator) {
            loadingIndicator.remove();
          }
          
          // Reset loading state
          assetSearchState.isLoading = false;
          
          if (pageNum === 1) {
            // For initial search, display empty results
            displayAssetResults('asset-results', [], selectAsset);
          }
        }
      })
      .catch(function(error) {
        console.error('Asset search failed:', error);
        
        // Remove the loading indicator if it exists
        const loadingIndicator = document.getElementById('load-more-indicator');
        if (loadingIndicator) {
          loadingIndicator.remove();
        }
        
        // Reset loading state
        assetSearchState.isLoading = false;
        
        if (pageNum === 1) {
          // For initial search, display empty results
          displayAssetResults('asset-results', [], selectAsset);
          handleErr(error);
        }
      });
  }).catch(error => {
    console.error('Error getting installation parameters:', error);
    
    // Use default asset type ID as fallback
    console.log(`Using default asset type ID for search: ${DEFAULT_INVENTORY_TYPE_ID}`);
    
    // Reset loading state
    assetSearchState.isLoading = false;
    
    // For initial search, display empty results
    displayAssetResults('asset-results', [], selectAsset);
    handleErr('Failed to load configuration. Please refresh and try again.');
  });
}

/**
 * Display asset search results
 * @param {string} containerId - ID of container element
 * @param {Array} results - Results to display
 * @param {Function} selectionCallback - Callback for when an item is selected
 * @param {boolean} isFromCache - Whether results are from cache
 */
function displayAssetResults(containerId, results, selectionCallback, isFromCache = false) {
  const container = document.getElementById(containerId);
  container.innerHTML = '';
  container.style.display = results.length ? 'block' : 'none';
  
  // Add refresh button and cache indicator at top
  if (results.length > 0) {
    const headerRow = document.createElement('div');
    headerRow.className = 'd-flex justify-content-between align-items-center mb-2 p-2 bg-light border-bottom search-header';
    
    // Create count and cache indicator
    const resultsCount = document.createElement('div');
    resultsCount.className = 'small text-secondary';
    
    if (isFromCache) {
      resultsCount.innerHTML = `<i class="fas fa-database me-1"></i> ${results.length} cached results`;
    } else {
      resultsCount.innerHTML = `<i class="fas fa-search me-1"></i> ${results.length} results`;
    }
    
    // Create refresh button
    const refreshBtn = document.createElement('button');
    refreshBtn.className = 'btn btn-sm btn-outline-secondary';
    refreshBtn.innerHTML = '<i class="fas fa-sync-alt me-1"></i> Refresh';
    refreshBtn.title = 'Force refresh from API';
    refreshBtn.onclick = function(e) {
      e.stopPropagation();
      // Call searchAssets with force refresh flag
      searchAssets({
        target: { value: assetSearchState.currentSearchTerm },
        forceRefresh: true
      });
    };
    
    headerRow.appendChild(resultsCount);
    headerRow.appendChild(refreshBtn);
    container.appendChild(headerRow);
  }
  
  if (results.length === 0) {
    container.innerHTML = '<div class="list-group-item search-result-item no-results">No results found</div>';
    container.style.display = 'block';
    return;
  }
  
  results.forEach(result => {
    const resultItem = document.createElement('div');
    resultItem.className = 'list-group-item search-result-item d-flex flex-column search-item-hover';
    
    // Create a container for name and type badge
    const headerDiv = document.createElement('div');
    headerDiv.className = 'd-flex justify-content-between align-items-center w-100';
    
    // Name with proper styling (using display_name as priority)
    const nameDiv = document.createElement('div');
    nameDiv.className = 'fw-bold';
    nameDiv.textContent = result.display_name || result.name || 'Unnamed';
    
    // Add display ID/asset tag if available
    if (result.display_id || result.asset_tag) {
      const idSpan = document.createElement('span');
      idSpan.className = 'text-secondary ms-2';
      idSpan.style.fontSize = '0.9em';
      idSpan.textContent = result.asset_tag ? `#${result.asset_tag}` : `#${result.display_id}`;
      nameDiv.appendChild(idSpan);
    }
    
    headerDiv.appendChild(nameDiv);
    
    // Type badge and badges container
    const badgesDiv = document.createElement('div');
    badgesDiv.className = 'd-flex align-items-center gap-2';
    
    // Asset Type ID badge to help troubleshoot
    if (result.asset_type_id) {
      const typeIdBadge = document.createElement('span');
      typeIdBadge.className = 'badge bg-secondary text-white';
      typeIdBadge.title = 'Asset Type ID';
      typeIdBadge.textContent = `Type: ${result.asset_type_id}`;
      typeIdBadge.style.fontSize = '0.7em';
      badgesDiv.appendChild(typeIdBadge);
    }
    
    // Type badge - different colors for asset vs service
    const typeDiv = document.createElement('span');
    const isAsset = result.type === 'asset';
    typeDiv.className = `badge ${isAsset ? 'bg-success' : 'bg-warning text-dark'}`;
    typeDiv.textContent = isAsset ? 'Asset' : 'Service';
    badgesDiv.appendChild(typeDiv);
    
    headerDiv.appendChild(badgesDiv);
    resultItem.appendChild(headerDiv);
    
    // Additional information based on asset type
    const detailsContainer = document.createElement('div');
    detailsContainer.className = 'mt-2 d-flex flex-wrap gap-2';
    
    // Environment badge
    if (result.environment && result.environment !== 'N/A') {
      const envBadge = document.createElement('span');
      envBadge.className = 'badge bg-light text-dark border';
      envBadge.innerHTML = `<i class="fas fa-server me-1"></i>${result.environment}`;
      detailsContainer.appendChild(envBadge);
    }
    
    // Hosting model badge
    if (result.hosting_model && result.hosting_model !== 'N/A') {
      const hostingBadge = document.createElement('span');
      hostingBadge.className = 'badge bg-light text-dark border';
      hostingBadge.innerHTML = `<i class="fas fa-cloud me-1"></i>${result.hosting_model}`;
      detailsContainer.appendChild(hostingBadge);
    }
    
    // IP address badge
    if (result.ip_address && result.ip_address !== 'N/A') {
      const ipBadge = document.createElement('span');
      ipBadge.className = 'badge bg-light text-dark border';
      ipBadge.innerHTML = `<i class="fas fa-network-wired me-1"></i>${result.ip_address}`;
      detailsContainer.appendChild(ipBadge);
    }
    
    // Location badge
    if (result.location_name) {
      const locBadge = document.createElement('span');
      locBadge.className = 'badge bg-light text-dark border';
      locBadge.innerHTML = `<i class="fas fa-map-marker-alt me-1"></i>${result.location_name}`;
      detailsContainer.appendChild(locBadge);
    }
    
    // Managed by badge
    if (result.managed_by && result.managed_by !== 'N/A') {
      const managedBadge = document.createElement('span');
      managedBadge.className = 'badge bg-light text-dark border';
      managedBadge.innerHTML = `<i class="fas fa-user-cog me-1"></i>${result.managed_by}`;
      detailsContainer.appendChild(managedBadge);
    }
    
    // Asset type badge (as secondary information)
    if (result.asset_type_name) {
      const typeBadge = document.createElement('span');
      typeBadge.className = 'badge bg-light text-dark border';
      typeBadge.innerHTML = `<i class="fas fa-tag me-1"></i>${result.asset_type_name}`;
      detailsContainer.appendChild(typeBadge);
    }
    
    // Only add details container if we have any badges
    if (detailsContainer.children.length > 0) {
      resultItem.appendChild(detailsContainer);
    }
    
    // Add truncated description if available
    if (result.description) {
      const descriptionDiv = document.createElement('div');
      descriptionDiv.className = 'text-muted small mt-1';
      
      // Strip HTML tags and truncate if needed
      const textDescription = result.description.replace(/<[^>]*>/g, '');
      descriptionDiv.textContent = textDescription.length > 100 ? 
        textDescription.substring(0, 100) + '...' : textDescription;
      
      resultItem.appendChild(descriptionDiv);
    }
    
    resultItem.addEventListener('click', () => selectionCallback(result));
    container.appendChild(resultItem);
  });
}

function selectAsset(asset) {
  // Check if asset already exists in the selected list
  if (changeRequestData.selectedAssets.some(item => item.id === asset.id && item.type === asset.type)) {
    showNotification('error', 'This asset has already been added');
    return;
  }
  
  // Add to the selected assets list
  changeRequestData.selectedAssets.push(asset);
  renderSelectedAssets();
  
  // Clear the search
  document.getElementById('asset-results').style.display = 'none';
  document.getElementById('asset-search').value = '';
  
  // Save to data storage
  saveCurrentData();
}

function renderSelectedAssets() {
  try {
    const container = document.getElementById('selected-assets');
    if (!container) {
      console.warn('Selected assets container not found');
      return;
    }
    
    container.innerHTML = '';
    
    // Check if we have valid asset data
    if (!Array.isArray(changeRequestData.selectedAssets) || changeRequestData.selectedAssets.length === 0) {
      container.innerHTML = '<div class="empty-message text-secondary">No assets selected</div>';
      return;
    }
    
    // Create elements for each asset
    changeRequestData.selectedAssets.forEach((asset, index) => {
      if (!asset || typeof asset !== 'object') {
        console.warn(`Invalid asset data at index ${index}`);
        return; // Skip invalid asset
      }
      
      // Safely get asset properties
      const assetName = asset.display_name || asset.name || 'Unnamed Asset';
      const assetType = asset.type || 'unknown';
      const isAsset = assetType === 'asset';
      
      const assetItem = document.createElement('div');
      assetItem.className = 'asset-item mb-2 p-2 border rounded bg-light';
      
      const headerDiv = document.createElement('div');
      headerDiv.className = 'd-flex justify-content-between align-items-center';
      
      const nameSpan = document.createElement('span');
      nameSpan.className = 'fw-bold';
      nameSpan.textContent = assetName;
      
      // Add display ID/asset tag if available
      if (asset.display_id || asset.asset_tag) {
        const idSpan = document.createElement('span');
        idSpan.className = 'text-secondary ms-2';
        idSpan.style.fontSize = '0.9em';
        idSpan.textContent = asset.asset_tag ? `#${asset.asset_tag}` : `#${asset.display_id}`;
        nameSpan.appendChild(idSpan);
      }
      
      const badgeSpan = document.createElement('span');
      badgeSpan.className = `badge ${isAsset ? 'bg-success' : 'bg-warning text-dark'} me-2`;
      badgeSpan.textContent = isAsset ? 'Asset' : 'Service';
      
      const removeBtn = document.createElement('button');
      removeBtn.className = 'btn btn-sm btn-outline-danger remove-asset';
      removeBtn.innerHTML = 'âœ•';
      removeBtn.dataset.index = index;
      
      headerDiv.appendChild(nameSpan);
      
      const badgesDiv = document.createElement('div');
      badgesDiv.className = 'd-flex align-items-center';
      badgesDiv.appendChild(badgeSpan);
      badgesDiv.appendChild(removeBtn);
      
      headerDiv.appendChild(badgesDiv);
      assetItem.appendChild(headerDiv);
      
      // Add details if available
      const detailsContainer = document.createElement('div');
      detailsContainer.className = 'd-flex flex-wrap gap-2 mt-2';
      let hasDetails = false;
      
      // Environment badge
      if (asset.environment && asset.environment !== 'N/A') {
        hasDetails = true;
        const badge = document.createElement('span');
        badge.className = 'badge bg-light text-dark border';
        badge.innerHTML = `<i class="fas fa-server me-1"></i>${asset.environment}`;
        detailsContainer.appendChild(badge);
      }
      
      // Hosting model badge
      if (asset.hosting_model && asset.hosting_model !== 'N/A') {
        hasDetails = true;
        const badge = document.createElement('span');
        badge.className = 'badge bg-light text-dark border';
        badge.innerHTML = `<i class="fas fa-cloud me-1"></i>${asset.hosting_model}`;
        detailsContainer.appendChild(badge);
      }
      
      // IP address badge
      if (asset.ip_address && asset.ip_address !== 'N/A') {
        hasDetails = true;
        const badge = document.createElement('span');
        badge.className = 'badge bg-light text-dark border';
        badge.innerHTML = `<i class="fas fa-network-wired me-1"></i>${asset.ip_address}`;
        detailsContainer.appendChild(badge);
      }
      
      // Location badge
      if (asset.location_name) {
        hasDetails = true;
        const badge = document.createElement('span');
        badge.className = 'badge bg-light text-dark border';
        badge.innerHTML = `<i class="fas fa-map-marker-alt me-1"></i>${asset.location_name}`;
        detailsContainer.appendChild(badge);
      }
      
      // Managed by badge
      if (asset.managed_by && asset.managed_by !== 'N/A') {
        hasDetails = true;
        const badge = document.createElement('span');
        badge.className = 'badge bg-light text-dark border';
        badge.innerHTML = `<i class="fas fa-user-cog me-1"></i>${asset.managed_by}`;
        detailsContainer.appendChild(badge);
      }
      
      // Asset type badge (as secondary information)
      if (asset.asset_type_name) {
        hasDetails = true;
        const badge = document.createElement('span');
        badge.className = 'badge bg-light text-dark border';
        badge.innerHTML = `<i class="fas fa-tag me-1"></i>${asset.asset_type_name}`;
        detailsContainer.appendChild(badge);
      }
      
      if (hasDetails) {
        assetItem.appendChild(detailsContainer);
      }
      
      // Add truncated description if available
      if (asset.description) {
        const descriptionDiv = document.createElement('div');
        descriptionDiv.className = 'text-muted small mt-1';
        
        // Strip HTML tags and truncate if needed
        const textDescription = asset.description.replace(/<[^>]*>/g, '');
        descriptionDiv.textContent = textDescription.length > 100 ? 
          textDescription.substring(0, 100) + '...' : textDescription;
        
        assetItem.appendChild(descriptionDiv);
      }
      
      container.appendChild(assetItem);
    });
    
    // Add event listeners to remove buttons
    document.querySelectorAll('.remove-asset').forEach(button => {
      button.addEventListener('click', function() {
        try {
          const index = parseInt(this.dataset.index, 10);
          if (!isNaN(index) && index >= 0 && index < changeRequestData.selectedAssets.length) {
            changeRequestData.selectedAssets.splice(index, 1);
            renderSelectedAssets();
            saveCurrentData().catch(err => console.error('Error saving after asset removal:', err));
          }
        } catch (e) {
          console.error('Error removing asset:', e);
        }
      });
    });
  } catch (error) {
    console.error('Error rendering selected assets:', error);
  }
}

function showSummary() {
  if (changeRequestData.selectedAssets.length === 0) {
    showNotification('error', 'Please select at least one impacted asset');
    return;
  }
  
  const summaryContent = document.getElementById('summary-content');
  
  // Generate summary HTML with Bootstrap styling
  summaryContent.innerHTML = `
    <div class="summary-section mb-4">
      <h5>Change Details</h5>
      <hr>
      <div class="row">
        <div class="col-md-6">
          <p><strong>Requester:</strong> ${changeRequestData.requester.first_name} ${changeRequestData.requester.last_name}</p>
          <p><strong>Agent (Technical SME):</strong> ${changeRequestData.agent.first_name} ${changeRequestData.agent.last_name}</p>
          <p><strong>Change Type:</strong> ${changeRequestData.changeType}</p>
          <p><strong>Lead Time:</strong> ${changeRequestData.leadTime}</p>
        </div>
        <div class="col-md-6">
          <p><strong>Planned Start:</strong> ${formatDateTime(changeRequestData.plannedStart)}</p>
          <p><strong>Planned End:</strong> ${formatDateTime(changeRequestData.plannedEnd)}</p>
        </div>
      </div>
      
      <h6 class="mt-3">Implementation Plan</h6>
      <p class="text-secondary">${changeRequestData.implementationPlan || 'Not provided'}</p>
      
      <h6 class="mt-3">Backout (Recovery) Plan</h6>
      <p class="text-secondary">${changeRequestData.backoutPlan || 'Not provided'}</p>
      
      <h6 class="mt-3">Validation Plan</h6>
      <p class="text-secondary">${changeRequestData.validationPlan || 'Not provided'}</p>
    </div>
    
    <div class="summary-section mb-4">
      <h5>Risk Assessment</h5>
      <hr>
      <div class="row">
        <div class="col-md-6">
          <p><strong>Risk Score:</strong> ${changeRequestData.riskAssessment.totalScore}</p>
        </div>
        <div class="col-md-6">
          <p><strong>Risk Level:</strong> <span class="badge ${getRiskBadgeClass(changeRequestData.riskAssessment.riskLevel)}">${changeRequestData.riskAssessment.riskLevel}</span></p>
        </div>
      </div>
    </div>
    
    <div class="summary-section">
      <h5>Impacted Assets (${changeRequestData.selectedAssets.length})</h5>
      <hr>
      <ul class="list-group">
        ${changeRequestData.selectedAssets.map(asset => `<li class="list-group-item">${asset.name} <span class="badge bg-secondary">${asset.type}</span></li>`).join('')}
      </ul>
    </div>
  `;
  
  // Show the Bootstrap modal
  const modalElement = document.getElementById('confirmation-modal');
  const bootstrap = window.bootstrap || {};
  const confirmationModal = new bootstrap.Modal(modalElement);
  confirmationModal.show();
}

function closeModal() {
  const modalElement = document.getElementById('confirmation-modal');
  const bootstrap = window.bootstrap || {};
  const modal = bootstrap.Modal.getInstance(modalElement);
  if (modal) {
    modal.hide();
  }
}

async function submitChangeRequest() {
  try {
    // Here we would create the actual change request via the Freshservice API
    // For now, we'll just simulate success
    showNotification('success', 'Change request submitted successfully!');
    
    // Clear the saved draft after successful submission
    await clearSavedData();
    
    // Close the modal
    closeModal();
    
    // Reset form for new submission
    resetForm();
  } catch (error) {
    handleErr(error);
  }
}

function resetForm() {
  // Create a new object rather than mutating the existing one
  const newData = {
    requester: null,
    agent: null,
    changeType: 'standard',
    leadTime: '2 business days',
    plannedStart: '',
    plannedEnd: '',
    implementationPlan: '',
    backoutPlan: '',
    validationPlan: '',
    riskAssessment: {
      businessImpact: 0,
      affectedUsers: 0,
      complexity: 0,
      testing: 0,
      rollback: 0,
      totalScore: 0,
      riskLevel: ''
    },
    selectedAssets: []
  };
  
  // Replace the current data with the new object
  Object.keys(newData).forEach(key => {
    changeRequestData[key] = newData[key];
  });
  
  // Reset UI elements
  document.getElementById('selected-requester').textContent = '';
  document.getElementById('selected-requester').style.display = 'none';
  
  document.getElementById('selected-agent').textContent = '';
  document.getElementById('selected-agent').style.display = 'none';
  
  document.getElementById('change-type').value = 'standard';
  document.getElementById('lead-time').textContent = '2 business days';
  
  document.getElementById('planned-start').value = '';
  document.getElementById('planned-end').value = '';
  document.getElementById('implementation-plan').value = '';
  document.getElementById('backout-plan').value = '';
  document.getElementById('validation-plan').value = '';
  
  const riskRadios = document.querySelectorAll('.risk-options input[type="radio"]');
  riskRadios.forEach(radio => {
    radio.checked = false;
  });
  
  document.getElementById('risk-result').classList.add('hidden');
  document.getElementById('selected-assets').innerHTML = '';
  
  // Switch back to the first tab
  switchTab('change-details');
}

function formatDateTime(dateTimeString) {
  if (!dateTimeString) return '';
  const date = new Date(dateTimeString);
  return date.toLocaleString();
}

// Helper function for debouncing
function debounce(fn, delay) {
  // Define timeoutId in parent scope to avoid race condition
  let timeoutId = null;
  
  return function(...args) {
    const context = this;
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      fn.apply(context, args);
      timeoutId = null;
    }, delay);
  };
}

// Helper function for showing notifications with fallback
function showNotification(type, message) {
  console.log(`Notification (${type}): ${message}`);
  
  try {
    // Only use client interface if it's fully initialized
    if (window && window.client && window.client.interface && typeof window.client.interface.trigger === 'function') {
      // Map error type to danger for Bootstrap
      const notificationType = type === 'error' ? 'danger' : type;
      const safeMessage = message || 'Notification';
      
      window.client.interface.trigger('showNotify', { 
        type: notificationType,
        message: safeMessage
      }).catch(err => {
        console.error('Error showing notification via interface:', err);
        // If interface fails, try DOM fallback
        showFallbackNotification(type, message);
      });
    } else {
      // Use DOM fallback if client interface isn't available
      console.warn('Client interface not available, using fallback notification');
      showFallbackNotification(type, message);
    }
  } catch (error) {
    console.error('Failed to show notification:', error);
    // Final fallback if everything else fails
    showFallbackNotification(type, message);
  }
}

// DOM-based notification fallback
function showFallbackNotification(type, message) {
  try {
    // Ensure type is valid
    const validType = (type === 'error' || type === 'success' || type === 'info' || type === 'warning') ? type : 'info';
    
    // Remove any existing notifications
    const existingNotifications = document.querySelectorAll('.fallback-notification');
    existingNotifications.forEach(note => {
      if (note && note.parentNode) {
        note.parentNode.removeChild(note);
      }
    });
    
    // Create new notification element
    const notification = document.createElement('div');
    notification.className = `fallback-notification alert alert-${validType === 'error' ? 'danger' : validType}`;
    notification.style.position = 'fixed';
    notification.style.top = '20px';
    notification.style.right = '20px';
    notification.style.zIndex = '9999';
    notification.style.maxWidth = '300px';
    notification.style.padding = '10px 15px';
    notification.style.borderRadius = '4px';
    notification.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)';
    notification.textContent = message || 'Notification';
    
    // Add close button
    const closeBtn = document.createElement('button');
    closeBtn.type = 'button';
    closeBtn.className = 'btn-close';
    closeBtn.style.float = 'right';
    closeBtn.style.marginLeft = '10px';
    closeBtn.style.fontSize = '16px';
    closeBtn.style.fontWeight = 'bold';
    closeBtn.style.cursor = 'pointer';
    closeBtn.setAttribute('aria-label', 'Close');
    closeBtn.onclick = function() {
      if (notification && notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    };
    
    notification.prepend(closeBtn);
    document.body.appendChild(notification);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
      if (notification && notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, 5000);
  } catch (e) {
    console.error('Failed to create fallback notification:', e);
  }
}

function handleErr(err = 'None') {
  let errorMessage = 'An error occurred. Please try again.';
  
  // Log detailed error information
  console.error('Error occurred. Details:', err);
  
  // Try to extract a more specific error message if available
  try {
    if (typeof err === 'string') {
      errorMessage = err;
    } else if (err && err.message) {
      errorMessage = `Error: ${err.message}`;
    } else if (err && err.status && err.status.message) {
      errorMessage = `API Error: ${err.status.message}`;
    } else if (err && typeof err === 'object') {
      // Safely stringify objects
      try {
        errorMessage = `Error: ${JSON.stringify(err).substring(0, 100)}...`;
      } catch (jsonError) {
        errorMessage = 'Error: Could not format error details';
      }
    }
  } catch (e) {
    console.error('Error while processing error message:', e);
  }
  
  // Show error notification with the extracted message
  showNotification('error', errorMessage);
}

// Helper function to get appropriate Bootstrap badge class for risk level
function getRiskBadgeClass(riskLevel) {
  switch(riskLevel) {
    case 'Low':
      return 'bg-success';
    case 'Medium':
      return 'bg-warning text-dark';
    case 'High':
      return 'bg-danger';
    default:
      return 'bg-secondary';
  }
}

// Add this CSS to the top of your file
document.addEventListener('DOMContentLoaded', function() {
  // Add custom CSS for hover effect
  const style = document.createElement('style');
  style.textContent = `
    .search-item-hover {
      transition: background-color 0.2s ease;
      cursor: pointer;
    }
    .search-item-hover:hover {
      background-color: #f8f9fa;
    }
    .search-result-item {
      border-left: 3px solid transparent;
    }
    .search-result-item:hover {
      border-left: 3px solid #0d6efd;
    }
    /* Styles for scrollable results container */
    #asset-results {
      max-height: 400px;
      overflow-y: auto;
      position: relative;
      scroll-behavior: smooth;
    }
    #requester-results, #agent-results {
      max-height: 350px;
      overflow-y: auto;
    }
    /* Loading indicator styles */
    #load-more-indicator {
      border-top: 1px solid #eee;
      background-color: #f8f9fa;
      font-size: 0.9em;
    }
    /* Asset type badge styles */
    .badge.bg-secondary {
      font-weight: normal;
      opacity: 0.8;
    }
    /* Cache indicator styles */
    .search-header {
      position: sticky;
      top: 0;
      z-index: 10;
      background-color: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
    }
  `;
  document.head.appendChild(style);
});

/**
 * Calculate safe API request counts based on rate limits
 * @returns {Promise<Object>} - Object with calculated safe limits
 */
async function getSafeApiLimits() {
  try {
    // Get installation parameters
    const params = await getInstallationParams();
    const safetyMargin = parseInt(params.apiSafetyMargin) / 100 || DEFAULT_SAFETY_MARGIN / 100;
    
    // Get custom rate limits from settings
    const overallLimit = parseInt(params.rateLimitOverall) || DEFAULT_RATE_LIMITS.starter.overall;
    const listAgentsLimit = parseInt(params.rateLimitListAgents) || DEFAULT_RATE_LIMITS.starter.listAgents;
    const listRequestersLimit = parseInt(params.rateLimitListRequesters) || DEFAULT_RATE_LIMITS.starter.listRequesters;
    const listAssetsLimit = parseInt(params.rateLimitListAssets) || DEFAULT_RATE_LIMITS.starter.listAssets;
    const listTicketsLimit = parseInt(params.rateLimitListTickets) || DEFAULT_RATE_LIMITS.starter.listTickets;
    
    console.log(`Using safety margin: ${params.apiSafetyMargin}% (${safetyMargin})`);
    
    // Calculate safe number of requests (applying safety margin)
    return {
      overallLimit: Math.floor(overallLimit * safetyMargin),
      listAgentsPageLimit: Math.floor((listAgentsLimit * safetyMargin) / 100), // Each page is 100 agents
      listRequestersPageLimit: Math.floor((listRequestersLimit * safetyMargin) / 100), // Each page is 100 requesters
      listAssetsPageLimit: Math.floor((listAssetsLimit * safetyMargin) / 100), // Each page is 100 assets
      listTicketsPageLimit: Math.floor((listTicketsLimit * safetyMargin) / 100) // Each page is 100 tickets
    };
  } catch (error) {
    console.error('Error calculating API limits:', error);
    // Return default safe limits based on percentage safety margin
    const defaultSafetyMargin = DEFAULT_SAFETY_MARGIN / 100;
    return {
      overallLimit: Math.floor(DEFAULT_RATE_LIMITS.starter.overall * defaultSafetyMargin),
      listAgentsPageLimit: Math.floor((DEFAULT_RATE_LIMITS.starter.listAgents * defaultSafetyMargin) / 100),
      listRequestersPageLimit: Math.floor((DEFAULT_RATE_LIMITS.starter.listRequesters * defaultSafetyMargin) / 100),
      listAssetsPageLimit: Math.floor((DEFAULT_RATE_LIMITS.starter.listAssets * defaultSafetyMargin) / 100),
      listTicketsPageLimit: Math.floor((DEFAULT_RATE_LIMITS.starter.listTickets * defaultSafetyMargin) / 100)
    };
  }
}

/**
 * Get app installation parameters
 * @returns {Promise<Object>} - Installation parameters
 */
async function getInstallationParams() {
  try {
    if (!window.client || typeof window.client.iparams === 'undefined') {
      console.warn('iparams client not available, using defaults');
      return {
        freshserviceDomain: '',
        apiKey: '',
        planType: 'starter',
        apiSafetyMargin: DEFAULT_SAFETY_MARGIN,
        rateLimitOverall: DEFAULT_RATE_LIMITS.starter.overall,
        rateLimitListTickets: DEFAULT_RATE_LIMITS.starter.listTickets,
        rateLimitListAssets: DEFAULT_RATE_LIMITS.starter.listAssets,
        rateLimitListAgents: DEFAULT_RATE_LIMITS.starter.listAgents,
        rateLimitListRequesters: DEFAULT_RATE_LIMITS.starter.listRequesters,
        searchCacheTimeout: DEFAULT_SEARCH_CACHE_TIMEOUT,
        paginationDelay: DEFAULT_PAGINATION_DELAY,
        assetTypeId: DEFAULT_INVENTORY_TYPE_ID
      };
    }
    
    const iparams = await window.client.iparams.get();
    console.log('Loaded installation parameters:', iparams);
    
    return {
      freshserviceDomain: iparams.freshservice_domain || '',
      apiKey: iparams.api_key || '',
      planType: (iparams.plan_type || 'starter').toLowerCase(),
      apiSafetyMargin: parseInt(iparams.api_safety_margin || DEFAULT_SAFETY_MARGIN),
      rateLimitOverall: parseInt(iparams.rate_limit_overall || DEFAULT_RATE_LIMITS.starter.overall),
      rateLimitListTickets: parseInt(iparams.rate_limit_list_tickets || DEFAULT_RATE_LIMITS.starter.listTickets),
      rateLimitListAssets: parseInt(iparams.rate_limit_list_assets || DEFAULT_RATE_LIMITS.starter.listAssets),
      rateLimitListAgents: parseInt(iparams.rate_limit_list_agents || DEFAULT_RATE_LIMITS.starter.listAgents),
      rateLimitListRequesters: parseInt(iparams.rate_limit_list_requesters || DEFAULT_RATE_LIMITS.starter.listRequesters),
      searchCacheTimeout: parseInt(iparams.search_cache_timeout || DEFAULT_SEARCH_CACHE_TIMEOUT),
      paginationDelay: parseInt(iparams.pagination_delay || DEFAULT_PAGINATION_DELAY),
      assetTypeId: parseInt(iparams.asset_type_id || DEFAULT_INVENTORY_TYPE_ID)
    };
  } catch (error) {
    console.error('Error getting installation parameters:', error);
    return {
      freshserviceDomain: '',
      apiKey: '',
      planType: 'starter',
      apiSafetyMargin: DEFAULT_SAFETY_MARGIN,
      rateLimitOverall: DEFAULT_RATE_LIMITS.starter.overall,
      rateLimitListTickets: DEFAULT_RATE_LIMITS.starter.listTickets,
      rateLimitListAssets: DEFAULT_RATE_LIMITS.starter.listAssets,
      rateLimitListAgents: DEFAULT_RATE_LIMITS.starter.listAgents,
      rateLimitListRequesters: DEFAULT_RATE_LIMITS.starter.listRequesters,
      searchCacheTimeout: DEFAULT_SEARCH_CACHE_TIMEOUT,
      paginationDelay: DEFAULT_PAGINATION_DELAY,
      assetTypeId: DEFAULT_INVENTORY_TYPE_ID
    };
  }
}

/**
 * Update loading message in a container
 * @param {string} containerId - ID of container element
 * @param {string} message - Message to display
 */
function updateLoadingMessage(containerId, message) {
  const container = document.getElementById(containerId);
  if (container) {
    container.innerHTML = `<div class="text-center p-3"><div class="spinner-border spinner-border-sm" role="status"></div> ${message}</div>`;
  }
}

/**
 * Fetch all asset types from the API and store them in the cache
 * @returns {Promise<Array>} - Cached asset types
 */
async function fetchAllAssetTypes() {
  console.log('Fetching all asset types from API');
  
  // Check for client availability
  if (!window.client || !window.client.request) {
    console.error('Client not available for asset types fetch');
    return [];
  }

  try {
    let allTypes = [];
    let page = 1;
    let hasMorePages = true;
    
    // Function to load asset types from a specific page
    async function loadAssetTypesPage(pageNum) {
      console.log(`Loading asset types page ${pageNum}`);
      
      try {
        // Use the template to access asset types API
        const data = await window.client.request.invokeTemplate("getAssetTypes", {
          path_suffix: `?page=${pageNum}&per_page=100`
        });
        
        if (!data || !data.response) {
          console.error('Invalid asset types response:', data);
          return { types: [], more: false };
        }
        
        try {
          const parsedData = JSON.parse(data.response || '{"asset_types":[]}');
          const types = parsedData.asset_types || [];
          
          // Check if we might have more pages (received full page of results)
          const hasMore = types.length === 100;
          
          return { types, more: hasMore };
        } catch (parseError) {
          console.error('Error parsing asset types response:', parseError);
          return { types: [], more: false };
        }
      } catch (error) {
        console.error(`Error fetching asset types page ${pageNum}:`, error);
        return { types: [], more: false };
      }
    }
    
    // Load all pages of asset types
    while (hasMorePages) {
      const { types, more } = await loadAssetTypesPage(page);
      
      // Process types and add to list
      allTypes = [...allTypes, ...types];
      
      // Check if we should load more pages
      hasMorePages = more;
      page++;
      
      // Safety check to prevent infinite loops
      if (page > 10) {
        console.warn('Reached maximum number of asset type pages (10)');
        break;
      }
    }
    
    // Save all asset types to cache
    if (allTypes.length > 0) {
      console.log(`Caching ${allTypes.length} asset types`);
      cacheAssetTypes(allTypes);
    } else {
      console.warn('No asset types found to cache');
    }
    
    return allTypes;
  } catch (error) {
    console.error('Error in fetchAllAssetTypes:', error);
    return [];
  }
}

/**
 * Save asset types to cache
 * @param {Array} types - Asset types to cache
 * @returns {boolean} - Success status
 */
function cacheAssetTypes(types) {
  try {
    // Update the list cache
    assetTypeCache.list = types;
    
    // Update the byId cache
    types.forEach(type => {
      if (type && type.id) {
        assetTypeCache.byId[type.id] = {
          name: type.name,
          description: type.description,
          data: type
        };
      }
    });
    
    // Update the timestamp
    assetTypeCache.timestamp = Date.now();
    console.log('Asset type cache updated with', types.length, 'types');
    return true;
  } catch (error) {
    console.error('Failed to save asset type cache:', error);
    return false;
  }
}

/**
 * Get asset type by ID with caching
 * @param {number} typeId - Asset type ID 
 * @returns {Object} - Asset type data or null
 */
async function getAssetType(typeId) {
  if (!typeId) return null;
  
  // Check if we need to refresh the cache
  if (assetTypeCache.timestamp === 0 || 
      Date.now() - assetTypeCache.timestamp > ASSET_TYPE_CACHE_TIMEOUT ||
      Object.keys(assetTypeCache.byId).length === 0) {
    console.log('Asset type cache expired or empty, refreshing...');
    await fetchAllAssetTypes();
  }
  
  // Return from cache if available
  if (assetTypeCache.byId[typeId]) {
    return assetTypeCache.byId[typeId];
  }
  
  // If not in cache, try to fetch just this one type
  try {
    console.log(`Asset type ${typeId} not found in cache, fetching individually...`);
    const data = await window.client.request.invokeTemplate("getAssetTypes", {
      path_suffix: `/${typeId}`
    });
    
    if (!data || !data.response) {
      console.error('Invalid asset type response:', data);
      return null;
    }
    
    const parsedData = JSON.parse(data.response || '{}');
    if (parsedData && parsedData.asset_type) {
      const assetType = parsedData.asset_type;
      
      // Add to cache
      assetTypeCache.byId[typeId] = {
        name: assetType.name,
        description: assetType.description,
        data: assetType
      };
      
      return assetTypeCache.byId[typeId];
    }
  } catch (error) {
    console.error(`Error fetching individual asset type ${typeId}:`, error);
  }
  
  return null;
}

// Variables to track current search state for infinite scroll
const assetSearchState = {
  currentSearchTerm: '',
  currentPage: 1,
  isLoading: false,
  hasMoreResults: true,
  totalResults: 0
};

/**
 * Display additional asset results when scrolling (appends to existing results)
 * @param {string} containerId - ID of container element
 * @param {Array} results - New results to append
 * @param {Function} selectionCallback - Callback for when an item is selected
 */
function displayAdditionalAssetResults(containerId, results, selectionCallback) {
  const container = document.getElementById(containerId);
  
  if (!container || results.length === 0) {
    return;
  }
  
  // Create elements for each new result
  results.forEach(result => {
    const resultItem = document.createElement('div');
    resultItem.className = 'list-group-item search-result-item d-flex flex-column search-item-hover';
    
    // Create a container for name and type badge
    const headerDiv = document.createElement('div');
    headerDiv.className = 'd-flex justify-content-between align-items-center w-100';
    
    // Name with proper styling (using display_name as priority)
    const nameDiv = document.createElement('div');
    nameDiv.className = 'fw-bold';
    nameDiv.textContent = result.display_name || result.name || 'Unnamed';
    
    // Add display ID/asset tag if available
    if (result.display_id || result.asset_tag) {
      const idSpan = document.createElement('span');
      idSpan.className = 'text-secondary ms-2';
      idSpan.style.fontSize = '0.9em';
      idSpan.textContent = result.asset_tag ? `#${result.asset_tag}` : `#${result.display_id}`;
      nameDiv.appendChild(idSpan);
    }
    
    headerDiv.appendChild(nameDiv);
    
    // Type badge and badges container
    const badgesDiv = document.createElement('div');
    badgesDiv.className = 'd-flex align-items-center gap-2';
    
    // Asset Type ID badge to help troubleshoot
    if (result.asset_type_id) {
      const typeIdBadge = document.createElement('span');
      typeIdBadge.className = 'badge bg-secondary text-white';
      typeIdBadge.title = 'Asset Type ID';
      typeIdBadge.textContent = `Type: ${result.asset_type_id}`;
      typeIdBadge.style.fontSize = '0.7em';
      badgesDiv.appendChild(typeIdBadge);
    }
    
    // Type badge - different colors for asset vs service
    const typeDiv = document.createElement('span');
    const isAsset = result.type === 'asset';
    typeDiv.className = `badge ${isAsset ? 'bg-success' : 'bg-warning text-dark'}`;
    typeDiv.textContent = isAsset ? 'Asset' : 'Service';
    badgesDiv.appendChild(typeDiv);
    
    headerDiv.appendChild(badgesDiv);
    resultItem.appendChild(headerDiv);
    
    // Additional information based on asset type
    const detailsContainer = document.createElement('div');
    detailsContainer.className = 'mt-2 d-flex flex-wrap gap-2';
    
    // Environment badge
    if (result.environment && result.environment !== 'N/A') {
      const envBadge = document.createElement('span');
      envBadge.className = 'badge bg-light text-dark border';
      envBadge.innerHTML = `<i class="fas fa-server me-1"></i>${result.environment}`;
      detailsContainer.appendChild(envBadge);
    }
    
    // Hosting model badge
    if (result.hosting_model && result.hosting_model !== 'N/A') {
      const hostingBadge = document.createElement('span');
      hostingBadge.className = 'badge bg-light text-dark border';
      hostingBadge.innerHTML = `<i class="fas fa-cloud me-1"></i>${result.hosting_model}`;
      detailsContainer.appendChild(hostingBadge);
    }
    
    // IP address badge
    if (result.ip_address && result.ip_address !== 'N/A') {
      const ipBadge = document.createElement('span');
      ipBadge.className = 'badge bg-light text-dark border';
      ipBadge.innerHTML = `<i class="fas fa-network-wired me-1"></i>${result.ip_address}`;
      detailsContainer.appendChild(ipBadge);
    }
    
    // Location badge
    if (result.location_name) {
      const locBadge = document.createElement('span');
      locBadge.className = 'badge bg-light text-dark border';
      locBadge.innerHTML = `<i class="fas fa-map-marker-alt me-1"></i>${result.location_name}`;
      detailsContainer.appendChild(locBadge);
    }
    
    // Managed by badge
    if (result.managed_by && result.managed_by !== 'N/A') {
      const managedBadge = document.createElement('span');
      managedBadge.className = 'badge bg-light text-dark border';
      managedBadge.innerHTML = `<i class="fas fa-user-cog me-1"></i>${result.managed_by}`;
      detailsContainer.appendChild(managedBadge);
    }
    
    // Asset type badge (as secondary information)
    if (result.asset_type_name) {
      const typeBadge = document.createElement('span');
      typeBadge.className = 'badge bg-light text-dark border';
      typeBadge.innerHTML = `<i class="fas fa-tag me-1"></i>${result.asset_type_name}`;
      detailsContainer.appendChild(typeBadge);
    }
    
    // Only add details container if we have any badges
    if (detailsContainer.children.length > 0) {
      resultItem.appendChild(detailsContainer);
    }
    
    // Add truncated description if available
    if (result.description) {
      const descriptionDiv = document.createElement('div');
      descriptionDiv.className = 'text-muted small mt-1';
      
      // Strip HTML tags and truncate if needed
      const textDescription = result.description.replace(/<[^>]*>/g, '');
      descriptionDiv.textContent = textDescription.length > 100 ? 
        textDescription.substring(0, 100) + '...' : textDescription;
      
      resultItem.appendChild(descriptionDiv);
    }
    
    resultItem.addEventListener('click', () => selectionCallback(result));
    container.appendChild(resultItem);
  });
}

/**
 * Process asset results to extract needed fields
 * @param {Array} assets - Raw assets from API
 * @returns {Array} - Processed assets with extracted fields
 */
function processAssetResults(assets) {
  return assets.map(asset => {
    // Extract fields from type_fields if available
    const typeFields = asset.type_fields || {};
    const assetTypeId = asset.asset_type_id;
    
    // Helper function to find the correct type field with asset_type_id suffix
    const getTypeField = (fieldPrefix) => {
      // Try with suffix first
      const suffixedKey = Object.keys(typeFields).find(key => 
        key.startsWith(fieldPrefix) && key.endsWith(`_${assetTypeId}`));
      
      // Return the value if found, otherwise null
      return suffixedKey ? typeFields[suffixedKey] : null;
    };
    
    return {
      id: asset.id,
      display_id: asset.display_id,
      name: asset.name || 'Unnamed Asset',
      display_name: asset.name || 'Unnamed Asset',
      type: 'asset',
      asset_type_id: asset.asset_type_id,
      asset_type_name: asset.asset_type_name,
      product_name: asset.product_name,
      location_name: asset.location_name,
      department_name: asset.department_name,
      asset_tag: asset.asset_tag,
      description: asset.description,
      // Try to get environment from suffixed type fields first
      environment: getTypeField('environment') || 
                  typeFields.environment || 
                  asset.custom_fields?.environment || 
                  asset.environment || 
                  'N/A',
      // Try to get IP address from suffixed type fields first
      ip_address: getTypeField('ip_address') || 
                 getTypeField('ip') || 
                 typeFields.ip_address || 
                 typeFields.ip || 
                 asset.custom_fields?.ip_address || 
                 asset.ip_address || 
                 asset.ip || 
                 'N/A',
      // Try to get managed by information - could be agent name, vendor, or owner
      managed_by: getTypeField('managed_by') || 
                 getTypeField('vendor') || 
                 typeFields.managed_by || 
                 typeFields.vendor || 
                 asset.custom_fields?.managed_by || 
                 asset.managed_by || 
                 asset.vendor_name || 
                 'N/A',
      // Add hosting model if available
      hosting_model: getTypeField('hosting_model') ||
                    typeFields.hosting_model ||
                    asset.custom_fields?.hosting_model ||
                    'N/A'
    };
  });
}

// Risk Assessment tab

/**
 * Get assets from cache with asset type filtering
 * @param {string} searchTerm - Search term used to find assets
 * @param {number} assetTypeId - Asset type ID to filter by
 * @returns {Promise<Array>} - Cached asset results or null if not found
 */
async function getAssetsByTypeFromCache(searchTerm, assetTypeId) {
  if (!assetTypeId) {
    return getFromSearchCache('assets', searchTerm);
  }
  
  const cacheKey = searchTerm || 'initial_asset_listing';
  
  // Initialize asset type cache if needed
  if (!searchCache.assetsByType[assetTypeId]) {
    searchCache.assetsByType[assetTypeId] = {};
  }
  
  // Check if we have a cache hit
  if (searchCache.assetsByType[assetTypeId][cacheKey]) {
    const cachedData = searchCache.assetsByType[assetTypeId][cacheKey];
    const currentTime = Date.now();
    
    // Get the configured search cache timeout
    const params = await getInstallationParams();
    const cacheTimeout = params.searchCacheTimeout || DEFAULT_SEARCH_CACHE_TIMEOUT;
    
    // Check if the cache is still valid
    if (currentTime - cachedData.timestamp < cacheTimeout) {
      return cachedData.results;
    } else {
      console.log(`Cache expired for asset type ${assetTypeId}, term "${cacheKey}"`);
    }
  }
  
  return null;
}

/**
 * Add assets to cache with asset type filtering
 * @param {string} searchTerm - Search term used to find assets
 * @param {number} assetTypeId - Asset type ID to filter by
 * @param {Array} results - Asset results to cache
 */
function addAssetsToTypeCache(searchTerm, assetTypeId, results) {
  if (!assetTypeId) {
    addToSearchCache('assets', searchTerm, results);
    return;
  }
  
  const cacheKey = searchTerm || 'initial_asset_listing';
  
  // Initialize asset type cache if needed
  if (!searchCache.assetsByType[assetTypeId]) {
    searchCache.assetsByType[assetTypeId] = {};
  }
  
  // Add the results to the cache
  searchCache.assetsByType[assetTypeId][cacheKey] = {
    results: results,
    timestamp: Date.now()
  };
  
  console.log(`Cached ${results.length} assets for type ${assetTypeId}, term "${cacheKey}"`);
}

